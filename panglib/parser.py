#!/usr/bin/env python

import sys, os, re

# Our modules
from . import stack, lexer

# Import your tables as parsedata, this way parser core stays the same
import  panglib.pangparse as parsedata

'''
The parser needs several variables to operate.
  Quick summary of variables:
    Token definitions, Lexer tokens, Parser functions,
    Parser states, Parse state table.
    See  pangparse.py for an example of required definitions.
'''

# Quick intro: The lexer creates a stack of tokens. The parser scans
# the tokens, and walks the state machine for matches. If match
# is encountered, the parser calls the function in the state table,
# and / or changes state. Reduce is called after the state has been
# successfully digested. For more info see lex / yacc literature.

# This variable controls the display of the default action.
# The default action is executed when there is no rule for the
# expression. Mostly useful for debugging the grammar.

_show_default_action = False

#parsedata.dumpids()
#parsedata.dumptokens()
#parsedata.dumpptable()

# ------------------------------------------------------------------------
# This parser creates no error conditions. Bad for languages, good
# for text parsing. Warnings can be generated by enabling the
# 'show_default' action.
# The parser is not fully recursive, so states need to be nested by
# hand. The flat parser is an advantage for text processing.

class Parser():

    def __init__(self, ptable, pvg = None):

        self.fstack = stack.Stack()
        self.fsm = parsedata.INIT;
        self.contflag = 0
        self.pvg = pvg
        self.pardict = {}

        # Create parse dictionary:
        for pt in parsedata.parsetable:
            if pt[0] != None:
                if pt[0][1] not in self.pardict:
                    self.pardict[pt[0][1]] = dict()     # Add if new
                dd = self.pardict[pt[0][1]]
                if pt[2]:
                    #print ("pt2", pt[2])
                    dd[ pt[2]] = pt[:]
                else:
                    self.add_class(dd, pt)
            else:
                for aa in pt[1]:
                    if aa[1] not in self.pardict:
                        self.pardict[aa[1]] = dict()  # Add if new
                    dd  = self.pardict[aa[1]]
                    if pt[2]:
                        #print ("pt2", pt[2])
                        dd[ pt[2] ] = pt[:]
                    else:
                        self.add_class(dd, pt)
        #self.dumptree()

    def dumptree(self):
        for sss in self.pardict.keys():
            print ("Key:", sss)
            for cc in self.pardict[sss].keys():
                print ("   Subkey:", parsedata.rlookup(cc), "(", cc, ")")
                print ("     ", self.pardict[sss][cc][:3])
                print ("     ",)
                for tttt in self.pardict[sss][cc][3:]:
                    print (tttt, parsedata.rlookup(tttt), end =" ")

    def parse(self, data, xstack):
        while True:
            tt = xstack.get2()  # Gen Next token
            if not tt:
                break
            self.parse_item(data, tt)

    def add_class(self, dd, pt):
        for aa in pt[3]:
            dd[ aa ] = pt[:]

    # This is the new routine, dictionary driven
    # About ten times as fast

    def parse_item(self, data, tt):

        #print("tt", tt)

        mmm = tt[1];
        self.strx = data[mmm.start():mmm.end()]

        if self.pvg.all:
            print ("parse_item", "'" + self.strx + "'")

        #print ("parser:", tt[0], "=", "'" + self.strx + "'"        )
        if self.pvg.show_state:
            print ("state:", self.fsm, "str:", "'" + self.strx + "' token:", tt[0]    )
        try:
            curr = self.pardict[self.fsm[1]]
        except:
            print ("no state on", tt[0], self.strx        )
        try:
            item = curr[tt[0][0]]
            if self.pvg.show_parse:
                print("item", item)
                # show context
                #bbb = mmm.start() - 5;  eee = mmm.end()+ 5
                #cont = data[bbb:mmm.start()] + "'" +  self.strx + "'" + \
                #        data[mmm.end():eee]
                cont = data[bbb:mmm.start()] + "'" +  self.strx + "'" + \
                        data[mmm.end():eee]
                #print("Cont:" "'" + cont + "'")
        except:
            print ("Exc: no key on", tt[0])
            return
            pass
        #print ("item:", item)
        if item[4] != None:
            item[4](self, tt, item)

        if item[5] == parsedata.REDUCE:
            # This is an actionless reduce ... rare
            self.reduce(tt)
        elif item[5] == parsedata.IGNORE:
            pass
        else:
            if self.pvg.show_state_change:
                print (" pushstate", self.fsm, "->", tt[0], self.strx)
            self.fstack.push([self.fsm, self.contflag, tt, self.strx])
            self.fsm = item[5]
            self.contflag = item[6]

    def popstate(self):
        old = self.fsm
        self.fsm, self.contflag, self.ttt, self.stry = self.fstack.pop()
        if self.pvg.show_state_change:
            print(" popstate", old, "->", self.fsm)

    def reduce(self):
        # Never called, just a p9laceholder
        print("reduce called");

if __name__ == "__main__":
    print ("This module was not meant to operate as main.")

# EOF
