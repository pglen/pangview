#!/usr/bin/env python

import sys, os, re, time

# Our modules
from . import stack, lexer

# Import your tables as parsedata, this way parser core stays the same
import  panglib.pangparse as parsedata
import  panglib.utils as utils

'''
The parser needs several variables to operate.
  Quick summary of variables:
    Token definitions, Lexer tokens, Parser functions,
    Parser states, Parse state table.
    See  pangparse.py for an example of required definitions.
'''

# Quick intro: The lexer creates a stack of tokens. The parser scans
# the tokens, and walks the state machine for matches. If match
# is encountered, the parser calls the function in the state table,
# and / or changes state. Reduce is called after the state has been
# successfully digested. For more info see lex / yacc literature.

# This variable controls the display of the default action.
# The default action is executed when there is no rule for the
# expression. Mostly useful for debugging the grammar.

_show_default_action = False

# ------------------------------------------------------------------------
# This parser creates no error conditions. Bad for languages, good
# for text parsing. Warnings can be generated by enabling the
# 'show_default' action.
# The parser is not fully recursive, so states need to be nested by
# hand. The flat parser is an advantage for text processing.

class Parser():

    def __init__(self, pvg = None):

        self.xstack = stack.Stack()
        self.fstack = stack.Stack()
        self.fsm = parsedata.st.INIT;
        self.contflag = 0
        self.pvg = pvg
        self.pardict = {}
        self.strx = ""

        # Create parse dictionary:
        for pt in parsedata.parsetable:
            if pt[0] != None:
                if pt[0][1] not in self.pardict:
                    self.pardict[pt[0][1]] = dict()     # Add if new
                dd = self.pardict[pt[0][1]]
                if pt[2]:
                    #print ("pt2", pt[2])
                    dd[ pt[2]] = pt[:]
                else:
                    self.add_class(dd, pt)
            else:
                if pt[1] != None:
                    for aa in pt[1]:
                        if aa[1] not in self.pardict:
                            self.pardict[aa[1]] = dict()  # Add if new
                        dd  = self.pardict[aa[1]]
                        if pt[2]:
                            #print ("pt2", pt[2])
                            dd[ pt[2] ] = pt[:]
                        else:
                            self.add_class(dd, pt)
        #self.dumptree("aa")

    def dumptree(self, file = None):

        if file:
            fp = open(file, "w")
        else:
            fp = sys.stdout

        for sss in self.pardict.keys():
            print ("Key:", sss, file=fp)
            for cc in self.pardict[sss].keys():
                print ("   Subkey:", parsedata.rlookup(cc), "(", cc, ")", file=fp,)
                print ("     ", self.pardict[sss][cc][:3], file=fp, )
                print ("     ", end = " ", file=fp, )
                for tttt in self.pardict[sss][cc][3:]:
                    print (tttt, parsedata.rlookup(tttt), end = " ", file=fp, )
            print(file=fp)

    def process(self, buf):
        self.lexit(buf)
        self.parse()

    def lexit(self, buf):
        self.data = buf
        self.got_clock =  time.clock()
        lexer.Lexer(self.data, self.xstack, parsedata.tokens)
        if self.pvg.show_timing:
            print  ("lexer:", time.clock() - self.got_clock)

        if self.pvg.show_lexer:  # To show what the lexer did
            for aa in range(self.xstack.stacklen()):
                bb = self.xstack.value(aa)
                ss = bb[1].span()
                strx = bb[1].string[ss[0]:ss[1]]
                print(bb[0], utils.esc(strx), bb[2:])

    def parse(self):
        self.got_clock =  time.clock()
        while True:
            tt = self.xstack.get2()  # Gen Next token
            if not tt:
                break
            self.parse_item(self.data, tt)
        parsedata.cb.flush()
        #self.dumptree("bb")

    def add_class(self, dd, pt):
        for aa in pt[3]:
            dd[aa] = pt[:]

    # This is the new routine, dictionary driven
    # About ten times as fast

    def parse_item(self, data, tt):

        #print("parse_item tt:", tt[0], tt[1].span())
        mmm = tt[1];
        self.oldstrx = utils.esc(self.strx)
        self.strx = data[mmm.start():mmm.end()]
        if self.pvg.all:
            print ("parse_item", tt[0], "'" + utils.esc(self.strx) + "'")
        #print ("parser:", tt[0], "=", "'" + self.strx + "'"        )
        if self.pvg.show_state:
            print ("state:", self.fsm, "str:", "'" + utils.esc(self.strx) + "' token:", tt[0]    )
        try:
            curr = self.pardict[self.fsm[1]]
            #print("fsm", self.fsm)
            #for aa in curr:
            #    print(parsedata.rlookup(aa), end = " ")
            #print()
        except:
            print ("no state table on", self.fsm, tt[0], self.strx, sys.exc_info())

        try:
            item = curr[tt[0][0]]
            if self.pvg.show_parse:
                #print("\nitem:", item)
                # show context
                #bbb = mmm.start() - 5;  eee = mmm.end()+ 5
                #cont = data[bbb:mmm.start()] + "'" +  self.strx + "'" + \
                #        data[mmm.end():eee]
                #cont = data[bbb:mmm.start()] + "'" +  self.strx + "'" + \
                #        data[mmm.end():eee]
                #print("Cont:" "'" + cont + "'")
                pass
        except:
            print ("no item on", "tt = ",  tt, sys.exc_info())
            #utils.put_exc("no item on:")
            #print("curr", curr[tt[0]])
            #for aa in curr:
            #    print(aa)
            return
            pass
        #print ("item:", item)
        if item[4] != None:
            item[4](self, tt, item)

        if item[5] == parsedata.st.REDUCE:
            # This is an actionless reduce ... rare
            self.reduce(tt)
        elif item[5] == parsedata.st.IGNORE:
            pass
        else:
            if self.pvg.show_state_change:
                print (" pushstate", self.fsm, self.oldstrx, "->",
                            item[5], "tok:", tt[0], self.strx)
            self.pushstate(tt)
            self.fsm = item[5]
            self.contflag = item[6]

    def pushstate(self, tt):
        self.fstack.push([self.fsm, self.contflag, tt, self.strx])

    def popstate(self):
        old = self.fsm
        self.fsm, self.contflag, self.ttt, self.stry = self.fstack.pop()
        if self.pvg.show_state_change:
            print("  popstate", old, "->", self.fsm, self.stry)

    def reduce(self):
        # Never called, just a p9laceholder
        print("reduce called");

#parsedata.dumpids()
#parsedata.dumptokens()
#parsedata.dumpptable()

if __name__ == "__main__":
    print ("This module was not meant to operate as main.")

# EOF
